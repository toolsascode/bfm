# Development docker-compose with hot-reload
# This file is for DEVELOPMENT ONLY - uses volume mounts for live code updates
#
# Usage:
#   docker compose -f docker-compose.dev.yml up -d          # Start all services with hot-reload
#   docker compose -f docker-compose.dev.yml down            # Stop all services
#   docker compose -f docker-compose.dev.yml logs -f bfm     # View BFM server logs
#   docker compose -f docker-compose.dev.yml logs -f ffm     # View FFM frontend logs

x-default-logging: &logging
  logging:
    driver: "json-file"
    options:
      max-size: "5m"
      max-file: "2"
      tag: "{{.Name}}"

services:
  # PostgreSQL for state tracking
  postgres:
    <<: *logging
    image: postgres:16-alpine
    container_name: bfm-postgres-dev
    ports:
      - "5433:5432"
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=${BFM_STATE_DB_PASSWORD:-postgres}
      - POSTGRES_DB=migration_state
      - POSTGRES_MULTIPLE_DATABASES=dashcloud
    command: >
      postgres
      -c max_connections=200
      -c shared_buffers=256MB
      -c effective_cache_size=1GB
    volumes:
      - bfm-postgres-data-dev:/var/lib/postgresql/data
    networks:
      - bfm-network-dev
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  # BFM Server with hot-reload (Air)
  bfm-server:
    <<: *logging
    build:
      context: ../api
      dockerfile: deploy/Dockerfile.dev
    container_name: bfm-server-dev
    ports:
      - "7070:7070"  # HTTP API
      - "9090:9090"  # gRPC API
    environment:
      # Server Configuration
      - BFM_HTTP_PORT=7070
      - BFM_GRPC_PORT=9090
      - BFM_API_TOKEN=${BFM_API_TOKEN:-SFXfytYJr3RfrjPMgEkhTEukOGpjhtLEmmJFYv+7GHQ=}
      - BFM_SFM_PATH=${BFM_SFM_PATH:-/sfm}

      # State Database Configuration
      - BFM_STATE_BACKEND=postgresql
      - BFM_STATE_DB_HOST=postgres
      - BFM_STATE_DB_PORT=5432
      - BFM_STATE_DB_USERNAME=${BFM_STATE_DB_USERNAME:-postgres}
      - BFM_STATE_DB_PASSWORD=${BFM_STATE_DB_PASSWORD:-postgres}
      - BFM_STATE_DB_NAME=${BFM_STATE_DB_NAME:-migration_state}
      - BFM_STATE_SCHEMA=${BFM_STATE_SCHEMA:-public}

      # Core Backend Connection (matches SFM example: core connection)
      - CORE_BACKEND=postgresql
      - CORE_DB_HOST=${CORE_DB_HOST:-postgres}
      - CORE_DB_PORT=5432
      - CORE_DB_USERNAME=${CORE_DB_USERNAME:-postgres}
      - CORE_DB_PASSWORD=${CORE_DB_PASSWORD:-postgres}
      - CORE_DB_NAME=${CORE_DB_NAME:-migration_state}
      - CORE_SCHEMA=core

      # Logs Backend Connection (matches SFM example: logs connection for GreptimeDB)
      - LOGS_BACKEND=greptimedb
      - LOGS_DB_HOST=${LOGS_DB_HOST:-}
      - LOGS_DB_PORT=${LOGS_DB_PORT:-4001}
      - LOGS_DB_USERNAME=${LOGS_DB_USERNAME:-}
      - LOGS_DB_PASSWORD=${LOGS_DB_PASSWORD:-}
      - LOGS_DB_NAME=${LOGS_DB_NAME:-}

      # Metadata Backend Connection (matches SFM example: metadata connection for Etcd)
      - METADATA_BACKEND=etcd
      - METADATA_DB_HOST=${METADATA_DB_HOST:-}
      - METADATA_DB_PORT=${METADATA_DB_PORT:-2379}
      - METADATA_DB_USERNAME=${METADATA_DB_USERNAME:-}
      - METADATA_DB_PASSWORD=${METADATA_DB_PASSWORD:-}
      - METADATA_ENDPOINTS=${METADATA_ENDPOINTS:-}
      - METADATA_PREFIX=/bfm/metadata/

      # Queue Configuration (disabled by default in dev)
      - BFM_QUEUE_ENABLED=${BFM_QUEUE_ENABLED:-false}
      - BFM_QUEUE_TYPE=${BFM_QUEUE_TYPE:-kafka}
    volumes:
      # Mount source code for hot-reload
      - ../api:/app
      # Mount SFM examples to /sfm (separate from /app to avoid mount conflicts)
      - ../examples/sfm:/sfm:ro
      # Exclude tmp directory from volume (let Air manage it)
      - /app/tmp
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - bfm-network-dev
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:7070/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # FFM Frontend with hot-reload (Vite)
  ffm:
    <<: *logging
    build:
      context: ../ffm
      dockerfile: Dockerfile.dev
    container_name: ffm-frontend-dev
    ports:
      - "4040:4040"  # Vite dev server
    environment:
      # Set DOCKER env var so Vite knows to use service name for proxy
      - DOCKER=true
      # Frontend Configuration (BFM_* prefix)
      - BFM_FRONTEND_API_URL=${BFM_FRONTEND_API_URL:-/api}
      - BFM_API_TOKEN=${BFM_API_TOKEN:-SFXfytYJr3RfrjPMgEkhTEukOGpjhtLEmmJFYv+7GHQ=}
      - BFM_FRONTEND_AUTH_ENABLED=${BFM_FRONTEND_AUTH_ENABLED:-true}
      - BFM_FRONTEND_AUTH_USERNAME=${BFM_FRONTEND_AUTH_USERNAME:-admin}
      - BFM_FRONTEND_AUTH_PASSWORD=${BFM_FRONTEND_AUTH_PASSWORD:-admin123}
      - NODE_ENV=development
    volumes:
      # Mount source code for hot-reload
      - ../ffm:/app
      # Preserve node_modules (use named volume to avoid conflicts)
      # Note: start.sh will install deps if volume is empty
      - ffm-node-modules:/app/node_modules
      # Exclude dist directory (let Vite manage it)
      - /app/dist
    depends_on:
      - bfm-server
    networks:
      - bfm-network-dev
    restart: unless-stopped

networks:
  bfm-network-dev:
    driver: bridge
    name: bfm-network-dev

volumes:
  bfm-postgres-data-dev:
    name: bfm-postgres-data-dev
  ffm-node-modules:
    name: ffm-node-modules-dev
